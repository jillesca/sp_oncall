"""Define the state structures for the agent."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Sequence, TypedDict, List, Dict, Any, Optional

from langgraph.graph import add_messages
from langgraph.managed import IsLastStep
from typing_extensions import Annotated
from langchain_core.messages import AnyMessage


@dataclass
class InputState:
    """Defines the input state for the agent, representing a narrower interface to the outside world.

    This class is used to define the initial state and structure of incoming data.
    """

    messages: Annotated[Sequence[AnyMessage], add_messages] = field(
        default_factory=list
    )
    """
    Messages tracking the primary execution state of the agent.

    Typically accumulates a pattern of:
    1. HumanMessage - user input
    2. AIMessage with .tool_calls - agent picking tool(s) to use to collect information
    3. ToolMessage(s) - the responses (or errors) from the executed tools
    4. AIMessage without .tool_calls - agent responding in unstructured format to the user
    5. HumanMessage - user responds with the next conversational turn

    Steps 2-5 may repeat as needed.

    The `add_messages` annotation ensures that new messages are merged with existing ones,
    updating by ID to maintain an "append-only" state unless a message with the same ID is provided.
    """

    remaining_steps: int = 25
    """
    Tracks the number of steps remaining for the agent execution loop.
    Required by LangGraph agent executors.
    """


@dataclass
class State(InputState):
    """Represents the complete state of the agent, extending InputState with additional attributes.

    This class can be used to store any information needed throughout the agent's lifecycle.
    """

    is_last_step: IsLastStep = field(default=False)
    """
    Indicates whether the current step is the last one before the graph raises an error.

    This is a 'managed' variable, controlled by the state machine rather than user code.
    It is set to 'True' when the step count reaches recursion_limit - 1.
    """

    # Additional attributes can be added here as needed.
    # Common examples include:
    # retrieved_documents: List[Document] = field(default_factory=list)
    # extracted_entities: Dict[str, Any] = field(default_factory=dict)
    # api_connections: Dict[str, Any] = field(default_factory=dict)

    # Ensure remaining_steps is present (inherited from InputState)


class ExecutedToolCall(TypedDict):
    """Represents the details of a specific tool call made by the executor LLM"""

    function: str  # Name of the tool called (e.g., "get_routing_info")
    params: Dict[str, Any]  # Parameters used for the function call
    result: Optional[
        Dict[str, Any]
    ]  # Structured result from the tool (if successful)
    error: Optional[str]  # Error message (if failed)
    detailed_findings: str  # Detailed findings from the step execution


class StepExecutionResult(TypedDict):
    """Represents the outcome of executing one natural language plan step"""

    investigation_report: str  # Report generated by the LLM for this step
    tools_limitations: str  # Limitations encountered during the step execution
    executed_calls: List[
        ExecutedToolCall
    ]  # List of actual tool calls the LLM made for this step


class GraphState(TypedDict):
    """The state object used by the LangGraph workflow"""

    user_query: str
    device_name: str
    objective: str  # Set by Input Validator & Planner
    working_plan_steps: List[str]  # Set by Input Validator & Planner
    execution_results: List[
        StepExecutionResult
    ]  # Appended to by Network Executor
    # Fields for the Objective Assessor node and loop control
    max_retries: int  # Initialized by Input Validator & Planner (e.g., 2 or 3)
    current_retries: int  # Initialized to 0 by Input Validator & Planner, incremented by Objective Assessor
    objective_achieved_assessment: Optional[
        bool
    ]  # Set by Objective Assessor. True to proceed to report, False to retry.
    assessor_feedback_for_retry: Optional[
        str
    ]  # Set by Objective Assessor for Network Executor if retrying
    assessor_notes_for_final_report: Optional[
        str
    ]  # Set by Objective Assessor for Report Generator

    summary: Optional[str]  # Final output from Report Generator
